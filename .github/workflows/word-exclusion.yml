name: Word Exclusion

on:
  push:
    branches:
      - 'main'
      
  pull_request_target:
    branches:
      - 'main'

jobs:
  word_exclusion:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Install PowerShell Core
        run: |
          # Import the Microsoft repository GPG key
          wget -q https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb
          sudo dpkg -i packages-microsoft-prod.deb
          # Install PowerShell Core
          sudo apt-get update
          sudo apt-get install -y powershell
              
      - name: Get file list from .gitattributes in tmo-main branch
        id: get_file_list
        run: |
          git show origin/main:.gitattributes > gitattributes_temp.txt
          echo "Content of gitattributes_temp.txt:"
          Get-Content -Path gitattributes_temp.txt
          $FileList = Get-Content -Path gitattributes_temp.txt |
                      Select-Object -Skip 17 |
                      Select-String -Pattern '^(.*?)(?=\smerge=ours|$)' |
                      ForEach-Object { $_.Matches.Groups[1].Value }

          echo "Content of the extracted file list:"
          $FileList

          if ($FileList.Count -eq 0) {
            echo "No files were extracted from .gitattributes. Check the pattern or file content."
            exit 1
          }
          $FileList | Out-File -Encoding utf8 file_list.txt
        shell: pwsh

      - name: Word Exclusion
        run: |
          $Patterns = @("^(private)$", "^(tracker)", "^(pets)")
          $PathToCheck = $env:GITHUB_WORKSPACE
          $Matches = @()

          # Get the list of changed files (for PR) or the list of all files (for push) in the current directory
          $ChangedFiles = Get-ChildItem -Path $PathToCheck | ForEach-Object { $_.FullName }


          # Read the list of files to check from file_list.txt
          $FileList = Get-Content file_list.txt

          # Find matches in directory names and file names for changed files
          $ChangedFiles | ForEach-Object {
              $Type = if (Test-Path $_ -PathType Container) { "dir" } else { "filename" }
              $Name = $_
              foreach ($Pattern in $Patterns) {
                  $MatchesInFile = Select-String -Path $Name -Pattern $Pattern
                  foreach ($Match in $MatchesInFile) {
                      $Matches += New-Object PSObject -Property @{
                          Type = $Type
                          Match = $Pattern
                          Name = $Name
                      }
                  }
              }
          }

          # Find matches in file contents for changed files
          $ChangedFiles | ForEach-Object {
              $FileName = $_
              foreach ($Pattern in $Patterns) {
                  if (Select-String -Path $FileName -Pattern $Pattern -Quiet) {
                      $Matches += New-Object PSObject -Property @{
                          Type = "file"
                          Match = $Pattern
                          Name = $FileName
                      }
                      break  # Exit the loop once a match is found
                  }
              }
          }

          # Find matches in directory names and file names for files to check from file_list.txt
          $NotFoundPaths = @()
          $FileList | ForEach-Object {
              $Type = if (Test-Path $_ -PathType Container) { "dir" } else { "filename" }
              $Name = $_
              foreach ($Pattern in $Patterns) {
                  try {
                      # Attempt to check if the path exists in this branch
                      if ($Name -match $Pattern) {
                          $Matches += New-Object PSObject -Property @{
                              Type = $Type
                              Match = $Pattern
                              Name = $Name
                          }
                          break  # Exit the loop once a match is found
                      }
                  }
                  catch {
                      # Add the path to the list of not found paths if it doesn't exist in this branch
                      $NotFoundPaths += $Name
                      break  # Exit the loop once a match is found
                  }
              }
          }

          # Find matches in file contents for files to check from file_list.txt
          $FileList | ForEach-Object {
              $FileName = $_
              foreach ($Pattern in $Patterns) {
                try {
                  $MatchesInFile = Select-String -Path $FileName -Pattern $Pattern
                  foreach ($Match in $MatchesInFile) {
                      $Matches += New-Object PSObject -Property @{
                          Type = "file"
                          Match = $Pattern
                          Name = $FileName
                      }
                  }
                }
                catch {
                      # Add the file path to the list of not found paths if it doesn't exist in the current directory
                      $NotFoundPaths += $FileName
                      break  # Exit the loop once a match is found
                  }     
              }
          }

          # Output gitattribute paths that were not found in this branch
          echo "Paths from .gitattributes not found in this branch:"
          foreach ($Path in $NotFoundPaths) {
              echo $Path
          }

          # Save matches to a variable
          $MatchedItems = $Matches

          # Output matches
          $MatchedItems

          # Convert the matches to JSON format
          $MatchesJson = $MatchedItems | ConvertTo-Json -Depth 100
          Write-Output $MatchesJson | Out-File matches.json
          
          # Fail the pipeline if matches.json is not empty
          if ((Get-Content -Path matches.json -Raw) -ne "") {
            echo "Word exclusion matches found."
            exit 1
          }

        shell: pwsh  # Use the PowerShell shell to execute the script

      - name: Upload Matches Artifact
        if: always()  # Ensure the step runs regardless of the pipeline status
        uses: actions/upload-artifact@v2
        with:
          name: matches-artifact
          path: matches.json
